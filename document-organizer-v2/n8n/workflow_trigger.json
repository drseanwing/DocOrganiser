{
  "name": "Document Organizer - Trigger Processing",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "download-complete",
        "responseMode": "responseNode",
        "options": {}
      },
      "id": "t1a2b3c4-d5e6-7890-abcd-ef1234567890",
      "name": "Webhook - Download Complete",
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [240, 300],
      "webhookId": "download-complete-webhook"
    },
    {
      "parameters": {
        "rule": {
          "interval": [
            {
              "field": "minutes",
              "minutesInterval": 5
            }
          ]
        }
      },
      "id": "t2b3c4d5-e6f7-8901-bcde-f12345678901",
      "name": "Schedule Check",
      "type": "n8n-nodes-base.scheduleTrigger",
      "typeVersion": 1.2,
      "position": [240, 500]
    },
    {
      "parameters": {
        "jsCode": "// Check for pending ZIP files in /data/input/\nconst fs = require('fs');\nconst path = require('path');\n\nconst inputDir = '/data/input';\nconst pendingFiles = [];\n\ntry {\n  if (fs.existsSync(inputDir)) {\n    const files = fs.readdirSync(inputDir);\n    \n    for (const file of files) {\n      // Match source_*.zip files that haven't been processed\n      if (file.startsWith('source_') && file.endsWith('.zip')) {\n        const processedMarker = file.replace('.zip', '.processed');\n        const processingMarker = file.replace('.zip', '.processing');\n        \n        // Skip if already processed or currently processing\n        if (!files.includes(processedMarker) && !files.includes(processingMarker)) {\n          const stats = fs.statSync(path.join(inputDir, file));\n          pendingFiles.push({\n            filename: file,\n            filepath: path.join(inputDir, file),\n            size: stats.size,\n            created: stats.birthtime,\n            modified: stats.mtime\n          });\n        }\n      }\n    }\n  }\n} catch (e) {\n  return [{ json: { error: e.message, pendingFiles: [] } }];\n}\n\nreturn pendingFiles.length > 0 \n  ? pendingFiles.map(f => ({ json: f }))\n  : [{ json: { noPendingFiles: true } }];"
      },
      "id": "t3c4d5e6-f7a8-9012-cdef-123456789012",
      "name": "Find Pending ZIPs",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [500, 500]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-has-pending",
              "leftValue": "={{ $json.noPendingFiles }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "notTrue"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "t4d5e6f7-a8b9-0123-def0-123456789abc",
      "name": "Has Pending Files?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [720, 500]
    },
    {
      "parameters": {
        "jsCode": "// Process webhook data from download workflow\nconst webhookData = $input.first().json;\n\nreturn [\n  {\n    json: {\n      filename: webhookData.zip_path ? webhookData.zip_path.split('/').pop() : 'unknown.zip',\n      filepath: webhookData.zip_path,\n      jobId: webhookData.job_id,\n      fileCount: webhookData.file_count,\n      fromWebhook: true\n    }\n  }\n];"
      },
      "id": "t5e6f7a8-b9c0-1234-ef01-23456789abcd",
      "name": "Parse Webhook Data",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [500, 300]
    },
    {
      "parameters": {
        "jsCode": "// Verify the ZIP file exists and is accessible\nconst fs = require('fs');\nconst path = require('path');\n\nconst input = $input.first().json;\nconst filepath = input.filepath;\nconst filename = input.filename;\n\ntry {\n  if (!fs.existsSync(filepath)) {\n    return [{\n      json: {\n        error: `ZIP file not found: ${filepath}`,\n        filename: filename,\n        exists: false\n      }\n    }];\n  }\n  \n  const stats = fs.statSync(filepath);\n  \n  // Create a processing marker file\n  const processingMarker = filepath.replace('.zip', '.processing');\n  fs.writeFileSync(processingMarker, JSON.stringify({\n    startedAt: new Date().toISOString(),\n    filename: filename\n  }));\n  \n  // Extract job ID from filename (source_<jobId>.zip)\n  const jobIdMatch = filename.match(/source_([a-f0-9-]+)\\.zip/i);\n  const jobId = jobIdMatch ? jobIdMatch[1] : input.jobId || null;\n  \n  return [{\n    json: {\n      filename: filename,\n      filepath: filepath,\n      size: stats.size,\n      jobId: jobId,\n      exists: true,\n      verified: true\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      error: e.message,\n      filename: filename,\n      filepath: filepath,\n      exists: false\n    }\n  }];\n}"
      },
      "id": "t6f7a8b9-c0d1-2345-f012-3456789abcde",
      "name": "Verify ZIP Exists",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [940, 400]
    },
    {
      "parameters": {
        "conditions": {
          "options": {
            "caseSensitive": true,
            "leftValue": "",
            "typeValidation": "strict"
          },
          "conditions": [
            {
              "id": "condition-verified",
              "leftValue": "={{ $json.verified }}",
              "rightValue": true,
              "operator": {
                "type": "boolean",
                "operation": "equals"
              }
            }
          ],
          "combinator": "and"
        },
        "options": {}
      },
      "id": "t7a8b9c0-d1e2-3456-0123-456789abcdef",
      "name": "ZIP Verified?",
      "type": "n8n-nodes-base.if",
      "typeVersion": 2,
      "position": [1160, 400]
    },
    {
      "parameters": {
        "method": "POST",
        "url": "http://processor:8000/process",
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "={\n  \"zip_path\": \"{{ $json.filepath }}\",\n  \"job_id\": \"{{ $json.jobId }}\",\n  \"callback_url\": \"http://n8n:5678/webhook/processing-status\"\n}",
        "options": {
          "timeout": 30000
        }
      },
      "id": "t8b9c0d1-e2f3-4567-1234-56789abcdef0",
      "name": "Trigger Container - HTTP",
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [1380, 300],
      "retryOnFail": true,
      "maxTries": 3,
      "waitBetweenTries": 5000,
      "continueOnFail": true
    },
    {
      "parameters": {
        "jsCode": "// Alternative: Use file-based trigger if HTTP fails\n// Container watches /data/input for new .trigger files\nconst fs = require('fs');\n\nconst input = $input.first().json;\nconst httpResponse = $('Trigger Container - HTTP').first().json;\n\n// Check if HTTP trigger succeeded\nif (httpResponse.status === 200 || httpResponse.accepted) {\n  return [{\n    json: {\n      method: 'http',\n      success: true,\n      jobId: input.jobId,\n      filepath: input.filepath,\n      response: httpResponse\n    }\n  }];\n}\n\n// Fallback to file-based trigger\ntry {\n  const triggerPath = input.filepath.replace('.zip', '.trigger');\n  const triggerData = {\n    zip_path: input.filepath,\n    job_id: input.jobId,\n    callback_url: 'http://n8n:5678/webhook/processing-status',\n    triggered_at: new Date().toISOString()\n  };\n  \n  fs.writeFileSync(triggerPath, JSON.stringify(triggerData, null, 2));\n  \n  return [{\n    json: {\n      method: 'file',\n      success: true,\n      jobId: input.jobId,\n      filepath: input.filepath,\n      triggerPath: triggerPath\n    }\n  }];\n} catch (e) {\n  return [{\n    json: {\n      method: 'failed',\n      success: false,\n      error: e.message,\n      jobId: input.jobId\n    }\n  }];\n}"
      },
      "id": "t9c0d1e2-f3a4-5678-2345-6789abcdef01",
      "name": "Handle Trigger Response",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [1600, 300]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE processing_jobs \nSET status = 'processing', \n    started_at = NOW(),\n    current_phase = 'processing'\nWHERE id = '{{ $json.jobId }}'\nRETURNING id, status, started_at;",
        "options": {}
      },
      "id": "tad1e2f3-a4b5-6789-3456-789abcdef012",
      "name": "Update Job - Processing",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1820, 300],
      "credentials": {
        "postgres": {
          "id": "postgres-credential-id",
          "name": "PostgreSQL"
        }
      }
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": true,\n  \"job_id\": \"{{ $json.id }}\",\n  \"status\": \"processing\",\n  \"message\": \"Processing triggered successfully\"\n}",
        "options": {}
      },
      "id": "tbe2f3a4-b5c6-7890-4567-89abcdef0123",
      "name": "Respond - Success",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [2040, 300]
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={\n  \"success\": false,\n  \"error\": \"{{ $json.error }}\",\n  \"message\": \"ZIP file verification failed\"\n}",
        "options": {
          "responseCode": 400
        }
      },
      "id": "tcf3a4b5-c6d7-8901-5678-9abcdef01234",
      "name": "Respond - Error",
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1.1,
      "position": [1380, 520]
    },
    {
      "parameters": {
        "jsCode": "// Log that no pending files were found\nreturn [{\n  json: {\n    message: 'No pending ZIP files found in /data/input',\n    checkedAt: new Date().toISOString()\n  }\n}];"
      },
      "id": "tda4b5c6-d7e8-9012-6789-abcdef012345",
      "name": "No Pending Files",
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [940, 620]
    },
    {
      "parameters": {
        "operation": "executeQuery",
        "query": "UPDATE processing_jobs \nSET status = 'failed',\n    error_message = 'ZIP verification failed: {{ $json.error }}'\nWHERE source_zip_path LIKE '%{{ $json.filename }}%'\nRETURNING id, status;",
        "options": {}
      },
      "id": "teb5c6d7-e8f9-0123-789a-bcdef0123456",
      "name": "Update Job - Failed",
      "type": "n8n-nodes-base.postgres",
      "typeVersion": 2.5,
      "position": [1380, 640],
      "credentials": {
        "postgres": {
          "id": "postgres-credential-id",
          "name": "PostgreSQL"
        }
      },
      "continueOnFail": true
    }
  ],
  "connections": {
    "Webhook - Download Complete": {
      "main": [
        [
          {
            "node": "Parse Webhook Data",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Schedule Check": {
      "main": [
        [
          {
            "node": "Find Pending ZIPs",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Find Pending ZIPs": {
      "main": [
        [
          {
            "node": "Has Pending Files?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Has Pending Files?": {
      "main": [
        [
          {
            "node": "Verify ZIP Exists",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "No Pending Files",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Parse Webhook Data": {
      "main": [
        [
          {
            "node": "Verify ZIP Exists",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Verify ZIP Exists": {
      "main": [
        [
          {
            "node": "ZIP Verified?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "ZIP Verified?": {
      "main": [
        [
          {
            "node": "Trigger Container - HTTP",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Respond - Error",
            "type": "main",
            "index": 0
          },
          {
            "node": "Update Job - Failed",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Trigger Container - HTTP": {
      "main": [
        [
          {
            "node": "Handle Trigger Response",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Handle Trigger Response": {
      "main": [
        [
          {
            "node": "Update Job - Processing",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Update Job - Processing": {
      "main": [
        [
          {
            "node": "Respond - Success",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {
    "executionOrder": "v1",
    "saveManualExecutions": true,
    "callerPolicy": "workflowsFromSameOwner",
    "errorWorkflow": ""
  },
  "staticData": null,
  "tags": [
    {
      "name": "Document Organizer"
    },
    {
      "name": "Cloud Integration"
    }
  ],
  "triggerCount": 2,
  "pinData": {},
  "versionId": "1.0.0"
}
